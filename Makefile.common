# -*- Makefile -*-

CC        ?= gcc
CXX       ?= g++
CC_LINKER ?= $(CXX)

# used to make gcc output header dependency information. All source
# files generated .d dependency definitions that are included at the
# bottom of this file
CCXXFLAGS += -MMD -MP

# always building with debug information. This is stripped into the -dbg
# packages by debhelper later
CCXXFLAGS += -g

# if no explicit optimization flags are given, optimize!
ifeq (,$(filter -O%,$(CCXXFLAGS)))
  CCXXFLAGS := $(CCXXFLAGS) -O3
endif

# I want the frame pointer. Makes walking the stack WAY easier
CCXXFLAGS += -fno-omit-frame-pointer


CCXXFLAGS += -Iinclude
CXXFLAGS += -std=c++0x

CCXXFLAGS +=					\
-DCDAS_CORE_SHARED_EXPORTS			\
-Wall						\
-Werror						\
-DCDAS_DEBUG					\
-fno-inline


LIB_SOURCES := $(wildcard $(addprefix src/*.,cpp cc C c cxx))
BIN_SOURCES := $(wildcard $(addprefix bin/*.,cpp cc C c cxx))
OBJECTS := $(SOURCES:.cpp=.o)

# default targetname comes from the directory name
ifeq (,$(TARGET_NAME))
  TARGET_NAME := lib$(shell echo $(notdir $(abspath .)) | tr . -)
endif

# if the TARGET_NAME is lib..., LIB_NAME is the same, otherwise prepend 'lib'
LIB_NAME           := $(if $(filter lib%,$(TARGET_NAME)),,lib)$(TARGET_NAME)
LIB_TARGET_SO_BARE := $(LIB_NAME).so
LIB_TARGET_SO	   := $(LIB_TARGET_SO_BARE).$(SO_VERSION)
LIB_TARGET_A       := $(LIB_NAME).a

LIB_OBJECTS := $(addsuffix .o,$(basename $(LIB_SOURCES)))
BIN_OBJECTS := $(addsuffix .o,$(basename $(BIN_SOURCES)))

# all objects built for inclusion in shared libraries get -fPIC. This is
# sub-optimal, since it adds the -fPIC overhead even if linking these
# statically, but this will have to do for now
$(LIB_OBJECTS): CCXXFLAGS += -fPIC


BIN_TARGETS := $(basename $(BIN_SOURCES))

# I make sure to give the .o to the linker before the .so and everything else.
# The .o may depend on the other stuff.
define gen_bintarget_dep =
$1: $1.o
	$$(CC_LINKER) $$(LDFLAGS)		\
		$$(filter %.o, $$^)		\
		$$(filter-out %.o, $$^)		\
		$$(LDLIBS) -o $$@
endef
$(foreach t,$(BIN_TARGETS),$(eval $(call gen_bintarget_dep,$t)))
# I statically link the library if I'm not installing; if I'm installing use dynamic linking
ifneq (,$(filter $(MAKECMDGOALS),install))
  $(BIN_TARGETS): $(LIB_TARGET_SO)
else
  $(BIN_TARGETS): $(LIB_TARGET_A)
endif




# define the compile rules. I need to redefine the rules here because my
# C..FLAGS variables are simple (immediately evaluated), but the user
# could have specified per-target flags that ALWAYS evaluate deferred-ly
cc_build_rule = $(CXX) $(CXXFLAGS) $(CCXXFLAGS) -c -o $@ $<
c_build_rule  = $(CC)  $(CFLAGS)   $(CCXXFLAGS) -c -o $@ $<
%.o:%.C
	$(cc_build_rule)
%.o:%.cc
	$(cc_build_rule)
%.o:%.cpp
	$(cc_build_rule)
%.o:%.c
	$(c_build_rule)
%.o: %.S
	$(CC) $(ASFLAGS) $(CPPFLAGS) -c -o $@ $<

$(LIB_TARGET_A): $(LIB_OBJECTS)
	ar rcv $@ $^


all: $(LIB_TARGET_SO) $(LIB_TARGET_A) $(BIN_TARGETS)
.PHONY: all
.DEFAULT_GOAL := all

clean:
	rm -rf src/*.o bin/*.o $(BIN_TARGETS) *.so *.so.* *.a
.PHONY: clean



# Here instead of specifying $^, I do just the %.o parts and then the
# others. This is required to make the linker happy to see the dependent
# objects first and the dependency objects last
$(LIB_TARGET_SO): LDFLAGS += -shared -Wl,--default-symver -fPIC -Wl,-soname,$(notdir $(LIB_TARGET_SO_BARE)).$(ABI_VERSION)


$(LIB_TARGET_SO_BARE) $(LIB_TARGET_SO_BARE).$(ABI_VERSION): | $(LIB_TARGET_SO)
$(LIB_TARGET_SO): $(LIB_OBJECTS)
	$(CC_LINKER) $(LDFLAGS) $^ $(LDLIBS) -o $@
	ln -fs $(notdir $@) $(LIB_TARGET_SO_BARE)
	ln -fs $(notdir $@) $(LIB_TARGET_SO_BARE).$(ABI_VERSION)










# #################### clean and all and install rules ##################

# # can't install unit tests
# ifeq ($(IS_UNIT_TEST),)
# include buildsystem/Makefile.install
# endif

# clean_files := $(addprefix $(dir)/, *.a *.o *.so *.so.*)
# clean_files += pod2htmi.tmp pod2htmd.tmp $(addprefix $(dir)/, *.1 *-man.html)

# clean_files += $(BIN_TARGET_ALL) $(EXTRACLEAN) $(LIB_OBJECTS) $(addsuffix .o,$(BIN_TARGET_ALL))

# # This is done with an eval to immediately evaluate the files-to-clean list
# define CLEAN_template
# $(dir)/clean:
# 	rm -rf $(clean_files) $(patsubst %.o,%.d,$(filter %.o,$(clean_files)))
# endef
# $(eval $(CLEAN_template))


# $(dir)/all: $(LIB_TARGET_A) $(BIN_TARGET_ALL)

# clean: $(dir)/clean
# distclean: clean

# # don't build unit tests unless asked
# ifeq ($(IS_UNIT_TEST),)
# all:   $(dir)/all
# endif # ifeq ($(IS_UNIT_TEST),)

# .PHONY: distclean clean all $(dir)/clean $(dir)/all










# installation business

# to lowercase, _ -> -
PACKAGENAME_BASE = $(shell echo $(TARGET_NAME) | tr A-Z_ a-z-)

# 'make install' installs files for packaging, while 'make localinstall' dumps
# them all together into a single directory. The only difference is the
# DESTDIR_DEV and DESTDIR_MAIN directories.

ifneq ($(filter $(MAKECMDGOALS),install),)
#{{{{{{{{{{{{{{ 'make install'
  # If the TARGET_NAME starts with 'lib', it's a library. Otherwise it's
  # binaries. Libraries have -dev versions of their packages, have ABI_VERSIONs,
  # and are allowed to have headers, .so, .a, etc. For each library I have 3
  # packages:
  #
  # liboblong-blahN    : main library, N is a number that gets bumped up with each API chage
  # liboblong-blah-dev : devel files (.a, .h, .pc)
  # liboblong-blahN-dbg: just the debug symbols

  ifeq ($(TARGET_NAME:lib%=lib),lib)
  #{{{{{{{{{{{{{{ library
    PACKAGENAME      := $(PACKAGENAME_BASE)$(ABI_VERSION)
    install: DESTDIR_DEV := debian/$(PACKAGENAME)-dev
  #}}}}}}}}}}}}}}
  else
  #{{{{{{{{{{{{{{ binary package
    PACKAGENAME      := $(PACKAGENAME_BASE)
  #}}}}}}}}}}}}}}
  endif

  install: DESTDIR_MAIN := debian/$(PACKAGENAME)
  .PHONY: install
#}}}}}}}}}}}}}} 'make install'
else
#{{{{{{{{{{{{{{ 'make localinstall'

  PACKAGENAME := localinstall

  localinstall: DESTDIR_DEV  := $(or $(DESTDIR),localinstall)
  localinstall: DESTDIR_MAIN := $(or $(DESTDIR),localinstall)

  localinstall: install
  .PHONY: localinstall
#}}}}}}}}}}}}}} 'make localinstall'
endif


.PHONY: install







# using 'cp -P' instead of 'install' because the latter follows links unconditionally
install: $(LIB_TARGET_A) $(LIB_TARGET_SO) $(LIB_TARGET_SO_BARE) $(LIB_TARGET_SO_BARE).$(ABI_VERSION) $(BIN_TARGETS)

# must have DESTDIR if we're doing an "install"
ifneq ($(filter $(MAKECMDGOALS),install),)
ifeq  ($(strip $(DESTDIR)),)
	@echo Tried to make install without having DESTDIR defined
	@echo "make install" is ONLY for the debian package.
	@echo What are you trying to do?
	@false
endif
endif
ifneq ($(LIB_OBJECTS),) # install non-dev library (can be in a non-lib project)
	mkdir -p $(DESTDIR_MAIN)/usr/lib
	cp -P $(LIB_TARGET_SO)  $(DESTDIR_MAIN)/usr/lib
	ln -fs $(notdir $(LIB_TARGET_SO)) $(DESTDIR_MAIN)/usr/lib/$(notdir $(LIB_TARGET_SO_BARE)).$(ABI_VERSION)
endif
ifeq ($(TARGET_NAME:lib%=lib),lib) # install dev library (MUST be in a lib project)
	mkdir -p $(DESTDIR_DEV)/usr/lib/$(REPO_NAME_ABI_VERSIONED)
	cp -P $(LIB_TARGET_A)   $(DESTDIR_DEV)/usr/lib/$(REPO_NAME_ABI_VERSIONED)
	ln -fs $(notdir $(LIB_TARGET_SO)) $(DESTDIR_DEV)/usr/lib/$(REPO_NAME_ABI_VERSIONED)/$(notdir $(LIB_TARGET_SO_BARE))
endif
ifneq ($(strip $(DIST_BINS)),)

	mkdir -p $(DESTDIR_MAIN)/usr/bin
	install -m 0755 $(DIST_BINS) $(DESTDIR_MAIN)/usr/bin/
endif
	mkdir -p $(DESTDIR_DEV)/usr/include
	cp -r include/* $(DESTDIR_DEV)/usr/include



# the header dependencies
-include *.d
